# Project function for the size based modelling package mizer

# Copyright 2012 Finlay Scott and Julia Blanchard.
# Copyright 2018 Gustav Delius and Richard Southwell.
# Development has received funding from the European Commission's Horizon 2020 
# Research and Innovation Programme under Grant Agreement No. 634495 
# for the project MINOUW (http://minouw-project.eu/).
# Distributed under the GPL 3 or later 
# Maintainer: Gustav Delius, University of York, <gustav.delius@york.ac.uk>

#' @useDynLib mizer
#' @importFrom Rcpp sourceCpp
NULL


#' Project size spectrum forward in time
#' 
#' Runs the size spectrum model simulation.
#' The function returns an object of type
#' \linkS4class{MizerSim} that can then be explored with a range of summary and
#' plotting methods.
#' 
#' @param params A \linkS4class{MizerParams} object
#' @param effort The effort of each fishing gear through time. See notes below.
#' @param t_max The maximum time the projection runs for. The default value is
#'   100. However, this argument is not needed if an array is used for the
#'   \code{effort} argument, in which case this argument is ignored. See notes
#'   below.
#' @param dt Time step of the solver. The default value is 0.1.
#' @param t_save The frequency with which the output is stored. The default
#'   value is 1. Must be an integer multiple of dt.
#' @param initial_n The initial populations of the species. By default the 
#'   \code{initial_n} slot of the \linkS4class{MizerParams} argument is used.
#'   See the notes below.
#' @param initial_n_pp The initial population of the plankton spectrum. It
#'   should be a numeric vector of the same length as the \code{w_full} slot of
#'   the \code{MizerParams} argument. By default the \code{initial_n_pp} slot of the
#'   \linkS4class{MizerParams} argument is used.
#'   ##AAsp##
#' @param initial_n_bb The initial population of the benthic spectrum. At the moment it is
#'  just follows the same code as for the plankton spectrum 
#' @param initial_n_aa The initial population of the algal spectrum. At the moment it is
#'  just follows the same code as for the plankton spectrum 
#'  @param shiny_progress A shiny progress object used to update shiny progress bar.
#'   Default NULL.
#' @param ... Currently unused.
#' 
#' @note The \code{effort} argument specifies the level of fishing effort during
#' the simulation. It can be specified in three different ways: \itemize{ \item
#' A single numeric value. This specifies the effort of all fishing gears which
#' is constant through time (i.e. all the gears have the same constant effort). 
#' \item A numerical vector which has the same length as the number of fishing
#' gears. The vector must be named and the names must correspond to the gear
#' names in the \code{MizerParams} object. The values in the vector specify the
#' constant fishing effort of each of the fishing gears, i.e. the effort is
#' constant through time but each gear may have a different fishing effort. 
#' \item A numerical array with dimensions time step x gear. This specifies the
#' fishing effort of each gear at each time step.  The first dimension, time,
#' must be named numerically and contiguously. The second dimension of the array
#' must be named and the names must correspond to the gear names in the
#' \code{MizerParams} argument. The value for the effort for a particular time
#' is used during the interval from that time to the next time in the array.}
#' 
#' If effort is specified as an array then the smallest time in the array is 
#' used as the initial time for the simulation. Otherwise the initial time is
#' set to 0. Also, if the effort is an array then the \code{t_max} argument is 
#' ignored and the maximum simulation time is the largest time of the effort
#' array.
#' 
#' The \code{initial_n} argument is a matrix with dimensions species x size. 
#' It specifies the abundances of the species at the initial time. The
#' order of species must be the same as in the \code{MizerParams} argument. If
#' the initial population is not specified, the argument is set by default by
#' the \code{get_initial_n} function which is set up for a North Sea model.
#' 
#' @return An object of type \linkS4class{MizerSim}.
#' 
#' @export
#' @seealso \code{\link{MizerParams}}
#' @examples
#' \dontrun{
#' # Data set with different fishing gears
#' data(NS_species_params_gears)
#' data(inter)
#' params <- MizerParams(NS_species_params_gears, inter)
#' # With constant fishing effort for all gears for 20 time steps
#' sim <- project(params, t_max = 20, effort = 0.5)
#' # With constant fishing effort which is different for each gear
#' effort <- c(Industrial = 0, Pelagic = 1, Beam = 0.5, Otter = 0.5)
#' sim <- project(params, t_max = 20, effort = effort)
#' # With fishing effort that varies through time for each gear
#' gear_names <- c("Industrial","Pelagic","Beam","Otter")
#' times <- seq(from = 1, to = 10, by = 1)
#' effort_array <- array(NA, dim = c(length(times), length(gear_names)),
#'     dimnames = list(time = times, gear = gear_names))
#' effort_array[,"Industrial"] <- 0.5
#' effort_array[,"Pelagic"] <- seq(from = 1, to = 2, length = length(times))
#' effort_array[,"Beam"] <- seq(from = 1, to = 0, length = length(times))
#' effort_array[,"Otter"] <- seq(from = 1, to = 0.5, length = length(times))
#' sim <- project(params, effort = effort_array)
#' }
#' 
project <- function(params, effort = 0,  t_max = 100, dt = 0.1, t_save=1,
                    temperature = rep(params@t_ref, times = t_max), # what do we do with the t_ref?
                    initial_n = params@initial_n,
                    initial_n_pp = params@initial_n_pp, 
                    initial_n_bb = params@initial_n_bb,
                    initial_n_aa = params@initial_n_aa,
                    shiny_progress = NULL, 
                    diet_steps=10,
                    #RF ####
                    mu = 1, resident = NULL, extinct = TRUE, RMAX = TRUE, prevSim = NULL,
                    OptMutant = "M1", M3List = NULL, checkpoint, print_it = TRUE, predMort = NULL,
                    ...) {  #default number of years (steps?) to calcualte diet for 
    # validObject(params)
  umbrella = FALSE # parameter that says if there are still things alive # might get rid of it
  t_save = dt

  if(is.na(temperature[1])) temperature = rep(params@t_ref, times = t_max) # if temperature is never specified by user we need temperature = tref so it has no effect
    
  # Do we need to create an effort array?
    if (is.vector(effort)) {
        no_gears <- dim(params@catchability)[1]
        if ((length(effort) > 1) & (length(effort) != no_gears)) {
            stop("Effort vector must be the same length as the number of fishing gears\n")
        }
        # If more than 1 gear need to check that gear names match
        gear_names <- dimnames(params@catchability)[[1]]
        effort_gear_names <- names(effort)
        if (length(effort) == 1 & is.null(effort_gear_names)) {
            effort_gear_names <- gear_names
        }
        if (!all(gear_names %in% effort_gear_names)) {
            gear_names_error_message <- paste("Gear names in the MizerParams object (", paste(gear_names, collapse=", "), ") do not match those in the effort vector.", sep="")
            stop(gear_names_error_message)
        }
        # Set up the effort array transposed so we can use the recycling rules
        time_dimnames <- signif(seq(from = 0, to = t_max, by = dt), 3)
        effort <- t(array(effort, dim = c(no_gears, length(time_dimnames)), 
                          dimnames = list(gear = effort_gear_names, time = time_dimnames)))
    }
    
    # Check that number and names of gears in effort array is same as in MizerParams object
    no_gears <- dim(params@catchability)[1]
    if(dim(effort)[2] != no_gears){
        no_gears_error_message <- paste("The number of gears in the effort array (length of the second dimension = ", dim(effort)[2], ") does not equal the number of gears in the MizerParams object (", no_gears, ").", sep="")
        stop(no_gears_error_message)
    }
    gear_names <- dimnames(params@catchability)[[1]]
    if(!all(gear_names %in% dimnames(effort)[[2]])){
        gear_names_error_message <- paste("Gear names in the MizerParams object (", paste(gear_names, collapse=", "), ") do not match those in the effort array.", sep="")
        stop(gear_names_error_message)
    }
    # Sort effort array to match order in MizerParams
    effort <- effort[,gear_names, drop=FALSE]
    
    # Blow up time dimension of effort array
    # i.e. effort might have been passed in using time steps of 1, but actual dt = 0.1, so need to blow up
    if (is.null(dimnames(effort)[[1]])){
        stop("The time dimname of the effort argument must be numeric.")
    }
    if (any(is.na(as.numeric(dimnames(effort)[[1]])))){
        stop("The time dimname of the effort argument must be numeric.")
    }
    time_effort <- as.numeric(dimnames(effort)[[1]])
    if (is.unsorted(time_effort)) {
        stop("The time dimname of the effort argument should be increasing.")
    }
    
    t_max <- time_effort[length(time_effort)] # RF might be source of bugs
    # Blow up effort so that rows are dt spaced
    time_effort_dt <- seq(from = time_effort[1], to = t_max, by = dt)
    effort_dt <- t(array(NA, dim = c(length(time_effort_dt), dim(effort)[2]), dimnames=list(time = time_effort_dt, dimnames(effort)[[2]])))
    for (i in 1:(length(time_effort)-1)){
        effort_dt[,time_effort_dt >= time_effort[i]] <- effort[i,]
    }
    effort_dt <- t(effort_dt)

    ## Temperature set-up
    ## at the moment we just repeat yearly values for the entire year, no smothing or interpolation is used
    if (length(temperature) == 1) {
      temperature = rep(temperature,t_max/dt)
      cat(sprintf("your temperature input vector is of size one, repeting it t_max times\n"))
    }
    
    #TODO
    # This section assume that temperature is a yearly value vector, not a year*dt one, commenting for now
    # if (length(temperature) != t_max) {
    #   stop("your temperature input vector is not the same length as t_max\n")
    # }
    # 
    # time_temperature_dt <- rep(temperature, length = t_max/dt, each = 1/dt) # works if t_max = length(temperature)
    time_temperature_dt <- temperature # we already give a year*dt temperature vector
    x_axis <- seq(length.out=(t_max/dt),from =1)   # = time vector
    # need smoothing?
    # myData <- data.frame("y" = time_temperature_dt, "x" = x_axis) # create dataframe for smoothing (not sure if needed)
    # temperature_dt <- matrix(predict(loess(y~x, myData, span = 0.1)), dimnames = list(x_axis, "temperature")) # temperature vector following dt
    temperature_dt <- matrix(time_temperature_dt, dimnames = list(x_axis, "temperature")) # without smoothing

    #arrays with scalar values for all time, species and size
    metTempScalar <- array(NA, dim = c(dim(params@species_params)[1], length(params@w), length(temperature_dt)), dimnames = list(params@species_params$species,params@w,temperature_dt)) 
    matTempScalar <- array(NA, dim = c(dim(params@species_params)[1], length(params@w), length(temperature_dt)), dimnames = list(params@species_params$species,params@w,temperature_dt)) 
    morTempScalar <- array(NA, dim = c(dim(params@species_params)[1], length(params@w), length(temperature_dt)), dimnames = list(params@species_params$species,params@w,temperature_dt)) 
    intTempScalar <- array(NA, dim = c(dim(params@species_params)[1], length(params@w), length(temperature_dt)), dimnames = list(params@species_params$species,params@w,temperature_dt)) 
    
    for(iSpecies in 1:dim(params@species_params)[1]) # fill the scalars arrays
    {
      metTempScalar[iSpecies,,] <-  tempFun(temperature = temperature_dt[,1], t_ref = params@t_ref, t_d = params@species_params$t_d[iSpecies], 
                                            Ea = params@species_params$ea_met[iSpecies], 
                                            c_a = params@species_params$ca_met[iSpecies],
                                            Ed = params@species_params$ed_met[iSpecies], 
                                            c_d = params@species_params$cd_met[iSpecies],w = params@w)
      
      matTempScalar[iSpecies,,] <-  tempFun(temperature = temperature_dt[,1], t_ref = params@t_ref, t_d = params@species_params$t_d[iSpecies],
                                            Ea = params@species_params$ea_mat[iSpecies], 
                                            c_a = params@species_params$ca_mat[iSpecies],
                                            Ed = params@species_params$ed_mat[iSpecies], 
                                            c_d = params@species_params$cd_mat[iSpecies],w = params@w)
      
      morTempScalar[iSpecies,,] <-  tempFun(temperature = temperature_dt[,1], t_ref = params@t_ref, t_d = params@species_params$t_d[iSpecies],
                                            Ea = params@species_params$ea_mor[iSpecies], 
                                            c_a = params@species_params$ca_mor[iSpecies],
                                            Ed = params@species_params$ed_mor[iSpecies], 
                                            c_d = params@species_params$cd_mor[iSpecies],w = params@w)
      
      intTempScalar[iSpecies,,] <-  tempFun(temperature = temperature_dt[,1], t_ref = params@t_ref, t_d = params@species_params$t_d[iSpecies],
                                            Ea = params@species_params$ea_int[iSpecies], 
                                            c_a = params@species_params$ca_int[iSpecies],
                                            Ed = params@species_params$ed_int[iSpecies], 
                                            c_d = params@species_params$cd_int[iSpecies],w = params@w)
    }
# print("dim(intTempScalar)=")
# print(dim(intTempScalar))
    # Make the MizerSim object with the right size
    # We only save every t_save steps
    # Divisibility test needs to be careful about machine rounding errors,
    # see https://github.com/sizespectrum/mizer/pull/2
    if((t_save < dt) || !isTRUE(all.equal((t_save - round(t_save / dt) * dt), 0)))
        stop("t_save must be a positive multiple of dt")
    t_skip <- round(t_save/dt)
    t_dimnames_index <- seq(1, to = length(time_effort_dt), by = t_skip)
    t_dimnames <- time_effort_dt[t_dimnames_index]
    sim <- MizerSim(params, t_dimnames = t_dimnames) 

    # Fill up the effort array
    sim@effort[] <- effort_dt[t_dimnames_index,]
    
    #attach temperature dimension and all the rate scalars to the sim object, so it is stored and can be viewed later
    sim@temperature <- temperature_dt
    sim@metTempScalar <- metTempScalar
    sim@matTempScalar <- matTempScalar
    sim@morTempScalar <- morTempScalar
    sim@intTempScalar <- intTempScalar
    sim@params@maxIntakeScalar <- apply(intTempScalar,c(1,2),max)

    # RF ####
    if(dim(sim@n)[2] == 1) dimnames(sim@n)$sp = 1
    else   dimnames(sim@n)$sp = rownames(initial_n) # the object created by mizer doesnt keep in memomry my mutant names, so Im putting them here
    



    # Handy things
    no_sp <- nrow(sim@params@species_params) # number of species
    no_w <- length(sim@params@w) # number of fish size bins
    no_w_full<- length(sim@params@w_full) # full size spectrum (including background spectra)

    idx <- 2:no_w
    # Hacky shortcut to access the correct element of a 2D array using 1D notation
    # This references the egg size bracket for all species, so for example
    # n[w_minidx_array_ref] = n[,w_min_idx]
    w_min_idx_array_ref <- (sim@params@w_min_idx - 1) * no_sp + (1:no_sp)
    
    # sex ratio - DO SOMETHING LATER WITH THIS
    sex_ratio <- 0.5
    
    #create a matrix for diet comparison. For prey it has the number of columns set at no_sp+3 because we have 3 background spectra
    # commenting as takes lots of time to compute somehow RF
    # sim@diet_comp<-array(0, c(no_sp, no_w, no_sp + 3, no_w_full), 
                         # dimnames=list( predator=as.character(params@species_params$species), pred_size = params@w, 
                         #                prey = c(as.character(params@species_params$species), "plankton", "benthos", "algae"),
                         #                prey_size = params@w_full))
    
    
    # Matrices for solver
    A <- matrix(0, nrow = no_sp, ncol = no_w)
    B <- matrix(0, nrow = no_sp, ncol = no_w)
    S <- matrix(0, nrow = no_sp, ncol = no_w)
    
    # Set initial population
    if (missing(prevSim) == TRUE) # RF ####
    {
      if (dim(sim@n_pp)[2] != length(initial_n_pp)){ # if this happens it means that the largest species went extinct in the previous run and that w_full shrank
        # I need now to adapt the old initial_n_pp to fit the new length of sim@n_pp
        # Will have to do this for algea and benthos one day too
print("n_pp issue")
        # print("sim@n_pp")
        # print(sim@n_pp)
        # print("init npp")
        # print(initial_n_pp)
      }
      
    sim@n[1,,] <- initial_n # probably need to change/tweak this bit
    sim@n_pp[1,] <- initial_n_pp
    sim@n_bb[1,] <- initial_n_bb
    sim@n_aa[1,] <- initial_n_aa
    # initialise n and nPP
    # We want the first time step only but cannot use drop as there may only be a single species
    n <- array(sim@n[1, , ], dim = dim(sim@n)[2:3])
    dimnames(n) <- dimnames(sim@n)[2:3]
    n_pp <- sim@n_pp[1, ]
    n_bb <- sim@n_bb[1, ]
    n_aa <- sim@n_aa[1, ]
    
    t_steps <- dim(effort_dt)[1] - 1
    # t_steps <- dim(effort_dt)[1] # RF ####
    init = 1 # for the for loop
    }

    else # this loop allow to continue the simulation where it stopped previously (on a time step point of view), if it has
    {
      # i_stop is not the real time step that the user enter, i_stop = i_step/dt
      # I'm going to start at the next i_step then
      t_init = prevSim$i_stop# round up / 
      
      # Set initial population
      # no need to do this as it is the final version, just take the previous matrix
      dimnames(sim@n)[[2]] <- rownames(initial_n) # updating the names accordingly (could do that during the object creation)
      # print("dims")
      # print(dim(sim@n))
      # print(dim(prevSim$n))
      sim@n[t_init, , ] <- prevSim$n # name bug here
      sim@n_pp[t_init, ] <- prevSim$n_pp
      sim@n_bb[t_init,] <- prevSim$n_bb
      sim@n_aa[t_init,] <- prevSim$n_aa

      # print(sim@n[,,1])
      # sim@n <- prevSim$n
      # sim@n_pp <- prevSim$n_pp
      # sim@n_bb <- prevSim$n_bb
      # sim@n_aa <- prevSim$n_aa


      # initialise n and nPP (pp is background)
      # We want the first time step only but cannot use drop as there may only be a single species
      n <- array(sim@n[t_init,,],dim=dim(sim@n)[2:3]) #take the first line of sim (for each weight) and put it in the matrix of right dimension (= sim@n at t=1)
      dimnames(n) <- dimnames(sim@n)[2:3] # now it has the weights as names
      n_pp <- sim@n_pp[t_init,] # no need for an array, there is only one line
      n_bb <- sim@n_bb[t_init, ]
      n_aa <- sim@n_aa[t_init, ]
      
      t_steps <- dim(effort_dt)[1] - 1 #time steps = max number of dt (not only the 100 saved)
      init = t_init # Simulation restart at last time step as the next time_step is calculated during the loop
      
      # print(n)
    }
    # the sim is fully initialised now, time to move forwards           
    #time projection
    
    # Set up progress bar
    # pb <- progress::progress_bar$new(
    #     format = "[:bar] :percent ETA: :eta",
    #     total = length(t_dimnames_index), width = 60)
    # if (hasArg(shiny_progress)) {
    #     # We have been passed a shiny progress object
    #     shiny_progress$set(message = "Running simulation", value = 0)
    #     proginc <- 1/length(t_dimnames_index)
    # }
    

    # If storing diet composition, make diet_comp_all array ahead of main loop 
    if (diet_steps>0){
      diet_comp_all<- array(0, dim(sim@diet_comp))
    }

    # cat(sprintf("number of time_step = %i\n",t_steps))
    for (i_time in init:t_steps) {
      
      if(i_time %% 100 == 0)
      {
      cat(sprintf("i_time = %i\n",i_time))
        # cat(sprintf("temp = %f\n",temperature_dt[i_time]))
      }

        # Do it piece by piece to save repeatedly calling methods

        # Calculate amount E_{a,i}(w) of available food
        avail_energy <- getAvailEnergy(sim@params, n = n, n_pp = n_pp, n_bb = n_bb, n_aa = n_aa) #, intakeScalar = sim@intTempScalar[,,i_time])
        
        # Calculate amount f_i(w) of food consumed
        feeding_level <- getFeedingLevel(sim@params, n = n, n_pp = n_pp, n_bb = n_bb, n_aa = n_aa, 
                                         avail_energy = avail_energy)
        
        # Calculate the predation rate
        pred_rate <- getPredRate(sim@params, n = n, n_pp = n_pp, n_bb = n_bb, n_aa = n_aa, 
                                 intakeScalar = sim@intTempScalar[,,i_time], feeding_level = feeding_level)
        
        # Calculate predation mortality on fish \mu_{p,i}(w)
        m2 <- getPredMort(sim@params, pred_rate = pred_rate, intakeScalar = sim@intTempScalar[,,i_time])
        
        # Calculate mortality on the plankton spectrum
        m2_background <- getPlanktonMort(sim@params, n = n, n_pp = n_pp, n_bb = n_bb, n_aa = n_aa, 
                                         intakeScalar = sim@intTempScalar[,,i_time], pred_rate = pred_rate)

                #Calculate mortality of the benthis spectrum 
        m2_benthos <- getBenthosMort(sim@params, n = n, n_pp = n_pp, n_bb = n_bb, n_aa = n_aa, 
                                         pred_rate = pred_rate)
        m2_algae <- getAlgalMort(sim@params, n = n, n_pp = n_pp, n_bb = n_bb, n_aa = n_aa, 
                                     pred_rate = pred_rate)
        
        # Calculate the resources available for reproduction and growth
        e <- getEReproAndGrowth(sim@params, n = n, n_pp = n_pp, n_bb = n_bb, n_aa = n_aa, 
                                intakeScalar = sim@intTempScalar[,,i_time], metScalar = sim@metTempScalar[,,i_time], 
                                feeding_level = feeding_level)
        #Moved total mortality calculation after the e calculation betcause we need e for stravation
        
        # Calculate total mortality \mu_i(w)
        z <- getMort(sim@params, n = n, n_pp = n_pp, n_bb = n_bb, n_aa = n_aa, 
                     intakeScalar = sim@intTempScalar[,,i_time], metScalar = sim@metTempScalar[,,i_time], 
                     morScalar = sim@morTempScalar[,,i_time], effort = effort_dt[i_time,], e = e, m2 = m2)
        
        # Calculate the resources for reproduction
        e_repro <- getERepro(sim@params, n = n, n_pp = n_pp, n_bb = n_bb, n_aa = n_aa, e = e, 
                             intakeScalar = sim@intTempScalar[,,i_time], metScalar = sim@metTempScalar[,,i_time])
        
        # Calculate the growth rate g_i(w)
        e_growth <- getEGrowth(sim@params, n = n, n_pp = n_pp, n_bb = n_bb, n_aa = n_aa, 
                               intakeScalar = sim@intTempScalar[,,i_time], metScalar = sim@metTempScalar[,,i_time], 
                               e_repro = e_repro, e = e)
        
        # R_{p,i}
        rdi <- getRDI(sim@params, n = n, n_pp = n_pp, n_bb = n_bb, n_aa = n_aa, 
                      intakeScalar = sim@intTempScalar[,,i_time], metScalar = sim@metTempScalar[,,i_time],
                      e_repro = e_repro, sex_ratio = sex_ratio)
        # R_i
        rdd <- getRDD(sim@params, n = n, n_pp = n_pp, n_bb = n_bb, n_aa = n_aa, rdi = rdi, 
                      intakeScalar = sim@intTempScalar[,,i_time],metScalar = sim@metTempScalar[,,i_time])

        # check if diet output is needed and if so call the diet comparison function 
        diet_store <- tail(t_dimnames_index, diet_steps) %in% (i_time + 1)
        
        if (any(diet_store)) {
          diet_comp_all[]<- getDietComp(sim@params, n=n,  n_pp=n_pp, n_bb = n_bb, n_aa = n_aa, 
                                        diet_comp_all=diet_comp_all, diet_steps=diet_steps, 
                                        intakeScalar = sim@intTempScalar[,,i_time])
          sim@diet_comp[]<-(diet_comp_all/diet_steps) + sim@diet_comp
        }
        # Iterate species one time step forward:
        # See Ken's PDF
        # A_{ij} = - g_i(w_{j-1}) / dw_j dt
        A[,idx] <- sweep(-e_growth[,idx-1,drop=FALSE]*dt, 2, sim@params@dw[idx], "/")
        # B_{ij} = 1 + g_i(w_j) / dw_j dt + \mu_i(w_j) dt
        B[,idx] <- 1 + sweep(e_growth[,idx,drop=FALSE]*dt,2,sim@params@dw[idx],"/") + z[,idx,drop=FALSE]*dt
        # S_{ij} <- N_i(w_j)
        S[,idx] <- n[,idx,drop=FALSE]
        # Boundary condition upstream end (recruitment)
        B[w_min_idx_array_ref] <- 1+e_growth[w_min_idx_array_ref]*dt/sim@params@dw[sim@params@w_min_idx]+z[w_min_idx_array_ref]*dt
        # Update first size group of n
        if(RMAX) n[w_min_idx_array_ref] <- (n[w_min_idx_array_ref] + rdd*dt/sim@params@dw[sim@params@w_min_idx]) / B[w_min_idx_array_ref]
        else n[w_min_idx_array_ref] <- (n[w_min_idx_array_ref] + rdi*dt/sim@params@dw[sim@params@w_min_idx]) / B[w_min_idx_array_ref]
        # Update n
        # for (i in 1:no_sp) # number of species assumed small, so no need to vectorize this loop over species
        #     for (j in (sim@params@w_min_idx[i]+1):no_w)
        #         n[i,j] <- (S[i,j] - A[i,j]*n[i,j-1]) / B[i,j]
        
        n <- inner_project_loop(no_sp = no_sp, no_w = no_w, n = n,
                                A = A, B = B, S = S,
                                w_min_idx = sim@params@w_min_idx)
        # Dynamics of plankton spectrum uses a semi-chemostat model (de Roos - ask Ken)
        # We use the exact solution under the assumption of constant mortality during timestep

        ###TODO?#### 
        # now we need to scale r_pp (not rr_pp!) with the temperature response. 
        # this could be done at the start again where we create rr_pp object. this means it will have an extra time dimension 
        # or we calcualte rr_pp scalar here at every time step, which might be simpler 
        tmp <- sim@params@rr_pp * sim@params@cc_pp / (sim@params@rr_pp + m2_background)

        n_pp <- tmp - (tmp - n_pp) * exp(-(sim@params@rr_pp + m2_background) * dt)
        
        ##AAsp####
        # Dynamics of benthic spectrum uses a semi-chemostat model 
        # currently it follows exactly the same rules as plankton but has it's own parameters
        tmp <- (sim@params@rr_bb * sim@params@cc_bb / (sim@params@rr_bb + m2_benthos))
        n_bb <- tmp - (tmp - n_bb) * exp(-(sim@params@rr_bb + m2_benthos) * dt)
        n_bb[sim@params@initial_n_bb == 0] <- 0 # destroy what's below (and above) threshold sizes
        
        # Dynamics of the algal spectrum uses a semi-chemostat model 
        # currently it follows exactly the same rules as plankton but has it's own parameters
        tmp <- (sim@params@rr_aa * sim@params@cc_aa / (sim@params@rr_aa + m2_algae))
        n_aa <- tmp - (tmp - n_aa) * exp(-(sim@params@rr_aa + m2_algae) * dt)
        n_aa[sim@params@initial_n_aa == 0] <- 0 # destroy what's below (and above) threshold sizes
        ##AAsp##
        
        # RF #### Extinction
        if (extinct == TRUE)
        {
          extinction = 1e-30
          # remove all rows with non-finite values
          n[!rowSums(!is.finite(n)), ]
          # replace all non-finite values with 1e-30 (not 0 but lower than extinction threshold)
          n[!is.finite(n)] <- 1e-30
          
          for (i in 1:no_sp)
          {
            if (sum(n[i,]) < extinction &
                # 0 < sum(n[i,]) &
                sim@params@species_params$extinct[i] == F 
                )
              # if species abundance under extinction threshold but not already extinct, kill it
            {
              n[i,] = 0
              # find the name of the species going extinct
              toto = which(sim@params@species_params$ecotype == rownames(n)[i])
              
              # if (sim@params@species_params$extinct[toto] == FALSE)
                # security for bugs
                if (print_it) cat(
                  sprintf(
                    "Extinction of species %s at time %s\n",
                    sim@params@species_params$ecotype[toto],
                    i_time
                  )
                )
              
              # else if (sim@params@species_params$extinct[toto] != FALSE)
              # {
              #   if (print_it)  cat(
              #     sprintf(
              #       "Species %s at time %s is a zombie\n",
              #       sim@params@species_params$ecotype[toto],
              #       i_time
              #     )
              #   ) # to check if they come back from the dead
              #   sim@params@species_params$erro[toto] = 1 # if this happen it will be noted by a 1 in the sp ID
              # }
              
              sim@params@species_params$extinct[toto] <-
                i_time + (checkpoint[[1]] - 1) * t_max / dt + checkpoint[[2]] # update the extinction status. checkpoint1 is current run number in the simulation, checkpoint2 add time if the simulation started from a previous one
              #print(sim@params@species_params)
              if (sim@params@species_params$extinct[toto] < sim@params@species_params$pop[toto])
                sim@params@species_params$error[toto] = 2 # if this happen it will be noted by a 2 in the sp ID
            } 
          }
          if (dim(sim@params@species_params[sim@params@species_params$extinct != FALSE,])[1] == dim(sim@params@species_params)[1])
            {umbrella = TRUE # if this is true, everything is dead
          cat(sprintf("everything is dead :(\n"))}
        }
        
        
        # Store results only every t_step steps.
        store <- t_dimnames_index %in% (i_time + 1)
        if (any(store)) {
            # Advance progress bar
          #  pb$tick() #Asta commented this out, because this produces huge amount of bars at every time step
            if (hasArg(shiny_progress)) {
                shiny_progress$inc(amount = proginc)
            }
            # Store result
            sim@n[which(store), , ] <- n 
            sim@n_pp[which(store), ] <- n_pp
            ##AAsp######
            sim@n_bb[which(store), ] <- n_bb
            sim@n_aa[which(store), ] <- n_aa
            ##AAsp#
        }
        
        # RF ####
        if (umbrella == TRUE) # in that case nothing is left and the simulation stop
        {
          if (print_it) cat(sprintf("Life has left your simulation, game over.\nSimulation stopped at time %s.\n", i_time))
          return(list(sim,umbrella)) #I just want something size 2
        }
        
        # EVOLUTION TIME
        mute = FALSE
        multiple = FALSE
        switch(OptMutant, # need to clear/update these options
               
               M2 = { # default mutation rate, with one mutant max per time step, randomly drawn from every species (not phenoytpes)
                 if (mu >= sample(1:1000, 1))
                 {
                   residentPool = sim@params@species_params[sim@params@species_params$extinct == FALSE,] # only keep the available residents (the one not extinct)
                   # to block exponential evolution of species, I'm first picking a lineage randomly and then an ecotype in this lineage
                   lineagePool = unique(residentPool$species)
                   
                   if (length(lineagePool) == 1) lineage = lineagePool else lineage = sample(lineagePool, 1)
                   
                   residentPool=residentPool[residentPool$species == lineage,]
                   resident <- sample(1:nrow(residentPool), 1) # this is the rownumber of the selected resident
                   resident <- residentPool$ecotype[resident] # this is his name now
                   mute = TRUE
                 }
               },
               M3 = { # if the user define a specific time to mutate, mainly for debugging
                 for (i in 1:length(M3List[[1]]))
                 {
                   if (M3List[[1]][i] == i_time)
                   {
                     residentPool = sim@params@species_params[sim@params@species_params$extinct == FALSE,] # only keep the available residents (the one not extinct)
                     #print(residentPool[,c(17,21)])
                     speciesPool = unique(residentPool$species) # which species are available to produce new phenotypes
                     challengers <- NULL
                     for (iSpecies in speciesPool) # do the picking for every species
                     {

                         #print(iSpecies)
                         #print(residentPool[residentPool$species == iSpecies,]$ecotype)
                         
                         if (length(residentPool[residentPool$species == iSpecies,]$ecotype)>1) 
                         {resident <- sample(residentPool[residentPool$species == iSpecies,]$ecotype, 1) # get the name of one phenotype in the selected species
                         } else {resident <- residentPool[residentPool$species == iSpecies,]$ecotype}
                         mute = TRUE
                         challengers <- c(challengers,resident)
                        
                     }
                     if (length(challengers)>1){
                       cat(sprintf("Possible new phenotypes\n"))
                       # print(challengers)
                       resident <- sample(challengers,1) # select only one to mutate (I know I'm lazy)
                     } else if (length(challengers == 1)) resident <- challengers
                   }}
               },
               M4 = { # multiple residents at one time, not sure if it still works
                 residentPool = sim@params@species_params[sim@params@species_params$extinct == FALSE,]
                 resident = NULL
                 for (i in 1:nrow(residentPool))
                 {
                   if (mu >= sample(1:1000, 1))
                   {
                     resident <- c(resident, rownames(residentPool)[i]) # this is his name now
                     mute = TRUE
                   }
                   if (length(resident) >1) multiple = TRUE
                 }
               },
               M5 = { # pick only one mutant but give a chance to every species
                 residentPool = sim@params@species_params[sim@params@species_params$extinct == FALSE,] # only keep the available residents (the one not extinct)
                 #print(residentPool[,c(17,21)])
                 speciesPool = unique(residentPool$species) # which species are available to produce new phenotypes
                 challengers <- NULL
                 for (iSpecies in speciesPool) # do the picking for every species
                 {
                   if (mu >= sample(1:1000, 1)) # if mutant happens
                   {
                     #print(iSpecies)
                     #print(residentPool[residentPool$species == iSpecies,]$ecotype)
                     
                     if (length(residentPool[residentPool$species == iSpecies,]$ecotype)>1) 
                     {resident <- sample(residentPool[residentPool$species == iSpecies,]$ecotype, 1) # get the name of one phenotype in the selected species
                     } else {resident <- residentPool[residentPool$species == iSpecies,]$ecotype}
                     mute = TRUE
                     challengers <- c(challengers,resident)
                   } 
                 }
                 if (length(challengers)>1){
                   cat(sprintf("Possible new phenotypes\n"))
                   # print(challengers)
                   resident <- sample(challengers,1) # select only one to mutate (I know I'm lazy)
                 } else if (length(challengers == 1)) resident <- challengers
               },
               {})
        
        if (multiple == FALSE)
        {
          if (print_it) cat(sprintf(
            "A mutant from species %s has appeared at time %s\n",
            resident,
            i_time
          ))}
        
        else 
        {
          if (print_it) cat(sprintf(
            "Mutants from species %s have appeared at time %s\n",
            resident,
            i_time
          ))}
        
        if (mute == TRUE & i_time!=t_steps & i_time!=t_steps-1) { # if  Iget a mutant on last time step I get bugs because the sim restart at last +1 time step, also need at least 2 time steps at the end as the code is optimised for matrices and not vector (cf stitch)
          # save the data
          sim_stop = sim
          # I need to get rid of the first or last line for no overlapping
          # it will be the first (initial conditions of this sim), but only after the first mutation
          # t_init +1 is the line number of the initialisation
          if (missing(prevSim) == FALSE) sim_stop@n[t_init+1,,]<- NA # if it's not the first run, delete the initialisation (first line where the mutant is introduce, easier for pasting later)
          
          i_stop = i_time +1 # to conserve the time of the projection to restart later | +1 cause time starts at 0
          stopList <- list(sim_stop, i_stop, resident,n,n_pp,n_bb,n_aa)
          names(stopList) <- c("data", "i_stop", "resident","n","n_pp","n_bb","n_aa")
          
          if(length(stopList)!=7) cat(sprintf("error in stop list, length is %i\n",length(stopList)))
          # now I need to leave the projection and keep resident, i_stop and sim_stop
# print("sim_stop")
# print(sim@n[,,1])
          return(stopList)
        }  
        
        
    }

    if (missing(prevSim) == FALSE) sim@n[t_init+1,,]<- NA # need to get rid of the initialisation for the last run before exiting
    # I'm keeping the if to not have this enable during the initialisation phase
    # I'm assuming that I have at least one mutant per run
    return(sim)
}


#' Calculate initial population abundances for the community populations
#' 
#' This function uses the model parameters and other parameters to calculate 
#' initial population abundances for the community populations. These initial 
#' abundances should be reasonable guesses at the equilibrium values. The 
#' returned population can be passed to the \code{project} function.
#' 
#' @param params The model parameters. An object of type \linkS4class{MizerParams}.
#' @param a A parameter with a default value of 0.35.
#' @param n0_mult Multiplier for the abundance at size 0. Default value is
#'   kappa/1000.
#' @export
#' @return A matrix (species x size) of population abundances.
#' @examples
#' \dontrun{
#' data(NS_species_params_gears)
#' params <- MizerParams(NS_species_params_gears)
#' init_n <- get_initial_n(params)
#' }
get_initial_n <- function(params, n0_mult = NULL, a = 0.35) {
    if (!is(params,"MizerParams"))
        stop("params argument must of type MizerParams")
    no_sp <- nrow(params@species_params)
    no_w <- length(params@w)
    initial_n <- array(NA, dim = c(no_sp, no_w))
    dimnames(initial_n) <- dimnames(params@intake_max)
    # N = N0 * Winf^(2*n-q-2+a) * w^(-n-a)
    # Reverse calc n and q from intake_max and search_vol slots (could add get_n function)
    n <- (log(params@intake_max[,1] / params@species_params$h) / log(params@w[1]))[1]
    q <- (log(params@search_vol[,1] / params@species_params$gamma) / log(params@w[1]))[1]
    # Guessing at a suitable n0 value based on kappa - this was figured out using trial and error and should be updated
    if (is.null(n0_mult)) {
        lambda <- 2 + q - n
        kappa <- params@cc_pp[1] / (params@w_full[1]^(-lambda))
        n0_mult <- kappa / 1000
    }
    initial_n[] <- unlist(tapply(params@w, 1:no_w, function(wx,n0_mult,w_inf,a,n,q)
        n0_mult * w_inf^(2 * n - q - 2 + a) * wx^(-n - a),
        n0_mult = n0_mult, w_inf = params@species_params$w_inf, a=a, n=n, q=q))
    #set densities at w > w_inf to 0
    initial_n[unlist(tapply(params@w,1:no_w,function(wx,w_inf) w_inf<wx, w_inf=params@species_params$w_inf))] <- 0
    # Also any densities at w < w_min set to 0
    initial_n[unlist(tapply(params@w,1:no_w,function(wx,w_min)w_min>wx, w_min=params@species_params$w_min))] <- 0    
    return(initial_n)
}
